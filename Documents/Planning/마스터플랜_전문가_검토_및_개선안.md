# 🔍 통합_웹사이트_구현_마스터플랜_v2 전문가 검토 및 개선안

**검토자:** AI 전문가
**검토일:** 2025-10-29
**평가:** ⚠️ 개선 필요 (권장 등급: v2.1)

---

## 📋 검토 요약

**전체 평가:** 🟡 **양호 (70점/100점)**

| 항목 | 평가 | 비고 |
|-----|------|------|
| 요구사항 명확성 | 🟢 우수 | 로스팅 데이터 기반 설계 명확함 |
| 기술 아키텍처 | 🟡 개선 필요 | 데이터 모델링, 성능 전략 부재 |
| 일정 계획 | 🟡 현실성 부족 | 버퍼 없음, 위험 요소 미반영 |
| 데이터 관리 | 🟡 미흡 | 버전 관리, 변경 추적 부족 |
| 운영 전략 | 🔴 부재 | 권한 관리, 모니터링 구체화 필요 |

---

## 🔴 주요 이슈 분석

### Issue 1: 혼합률 기반 원가 계산 로직의 오류 위험

**현재 설계:**
```
혼합 비중별 원가 = 각 원두 생두 원가 × 혼합률(%)
블렌드 총 원가 = Σ(혼합 비중별 원가)
최종 원가 = 블렌드 총 원가 / (1 - 손실률)
```

**문제점:**

#### 1-1. 혼합률(%)의 정의가 모호함

**현재:**
- "마사이 40%" = 혼합 비율?
- 생두 기준인가? 로스팅 후 기준인가?

**구체 예시 분석:**
```
풀문 블렌드 1kg 생산 기준:

시나리오 A: 혼합률 = 생두 기준
- 마사이 생두 400g (40%)
- 안티구아 생두 400g (40%)
- 모모라 생두 100g (10%)
- g4 생두 100g (10%)
= 생두 1,000g 입력

로스팅 후 (17% 손실 가정):
= 830g 출력

혼합 원가 계산:
- 마사이 원가: 30,000 × 40% = 12,000
- 안티구아 원가: 25,000 × 40% = 10,000
- 모모라 원가: 20,000 × 10% = 2,000
- g4 원가: 18,000 × 10% = 1,800
혼합 총 원가 = 25,800

최종 원가 = 25,800 / (1 - 0.17) = 25,800 / 0.83 = 31,084원/kg
```

**⚠️ 위험 인자:**
1. **혼합 기준의 불명확성**
   - 생두 기준 vs 로스팅 후 기준
   - 각 원두의 개별 손실률이 다를 경우?
   - 현재 데이터에서는 17% 통합 손실률만 있음

2. **실제 데이터와의 괴리**
   ```
   현재 데이터:
   - 풀문: 생두 26,505.9kg → 22,000kg (17.0% 손실)
   - 판매가: ₩22,000 (22kg당)

   생두 26,505.9kg에서:
   - 마사이: 10,602.4kg (40%)
   - 안티구아: 10,602.4kg (40%)
   - 모모라: 2,650.6kg (10%)
   - g4: 2,650.6kg (10%)

   이는 "생두 기준" 혼합이 맞음 ✓
   ```

3. **판매가 책정의 비논리성**
   ```
   풀문 최종 원가 = 31,084원/kg
   판매가 = 22,000원/kg

   → 손실! (수익율 -29%)
   ```

**개선안:**
```
1. 혼합률 정의 명확화
   - "생두 기준 혼합률(%)" 명시
   - 혼합 계산 시 생두량 기준 사용

2. 각 원두의 개별 손실률 추적 (선택 사항)
   - 현재: 통합 손실률만 있음 (17%)
   - 개별 원두별 손실률이 다를 경우 별도 관리

3. 판매가 재검증
   - 현재 ₩22,000이 실제 판매가인지 확인
   - 샘플 수량(22kg)의 실제 의미 파악
   - 원가 + 마진 = 판매가 검증

4. CostService 함수 재정의
   def calculate_blend_cost_per_kg(blend_id, unit='raw_kg'):
       """
       Args:
           blend_id: 블렌드 ID
           unit: 'raw_kg' (생두기준) or 'roasted_kg' (로스팅후기준)

       Returns:
           float: ₩/kg (생두 또는 로스팅후 기준)
       """
```

---

### Issue 2: 손실률 17%의 검증 부재

**현재 상황:**
- 모든 블렌드에 17% 손실률 고정
- 로스팅 기록에서 자동 계산되지만, 검증 로직 부재

**문제점:**

#### 2-1. 손실률 편차 미처리
```
현재 데이터:
- 풀문: (26,505.9 - 22,000) / 26,505.9 = 17.0%
- 뉴문: (4,819.3 - 4,000) / 4,819.3 = 17.0%

하지만 실제로는 원두별로 다를 수 있음:
- 가벼운 로스팅 (White): 손실률 10-12%
- 중간 로스팅 (Normal): 손실률 15-17%
- 어두운 로스팅 (Dark): 손실률 18-20%

혼합 블렌드는 평균이 17%이지만,
개별 원두로 입력할 때는?
```

#### 2-2. 이상 탐지 부재
```
시나리오:
- 한 달에 마사이만 따로 로스팅
- 손실률이 25%로 측정됨
- 시스템은 받아들임 (검증 없음)
→ 나중에 원가 계산 오류 발생
```

**개선안:**

```
1. 손실률 임계값 설정
   - 블렌드별 정상 범위 설정 (예: 풀문 16~18%)
   - 범위 벗어나면 경고

2. 원두별 손실률 추적 (선택 사항)
   roasting_logs 테이블에 추가:
   - loss_rate_percent (자동 계산: (raw - roasted) / raw)
   - expected_loss_rate_percent (마스터 데이터)
   - loss_variance_percent (편차)

   INSERT 트리거:
   IF loss_rate > expected ± 3%:
       log to warnings_table

3. 월별 손실률 통계
   SELECT
       roasting_month,
       bean_id,
       AVG(loss_rate_percent) as avg_loss,
       MIN(loss_rate_percent) as min_loss,
       MAX(loss_rate_percent) as max_loss,
       STDDEV(loss_rate_percent) as std_loss
   FROM roasting_logs
   GROUP BY roasting_month, bean_id

4. AnalyticsService 함수 추가
   def get_loss_rate_stats(bean_id=None, month=None):
       """손실률 통계 및 이상 탐지"""
       - 평균 vs 현재
       - 추이 분석
       - 이상 원인 가설
```

---

### Issue 3: 블렌드 레시피 버전 관리 부재

**현재 문제:**

```
2025-10-29: 풀문 = 마사이 40% + 안티구아 40% + 모모라 10% + g4 10%
2025-11-15: 풀문 = 마사이 35% + 안티구아 45% + 모모라 10% + g4 10%
            (비용 절감을 위해 마사이 비율 감소)

현재 DB:
- blend_recipes는 현재 레시피만 저장
- 과거 로스팅 기록은 어떤 레시피로 했는지 추적 불가
- 원가 분석 시 혼동 가능

예시:
SELECT roasting_logs WHERE bean_id=1 AND month='2025-10'
→ 마사이 로스팅량: 10,602kg
→ 과거 레시피(40%) 적용? 신규 레시피(35%) 적용? 불명확
```

**개선안:**

```
1. 테이블 구조 변경

현재:
CREATE TABLE blend_recipes (
    id, blend_id, bean_id, blending_ratio_percent
)

개선:
CREATE TABLE blend_recipes (
    id,
    blend_id,
    bean_id,
    blending_ratio_percent,
    version INTEGER DEFAULT 1,
    effective_date DATE NOT NULL,  # 이 레시피가 적용되는 시점
    is_current BOOLEAN DEFAULT true,
    notes VARCHAR(200),
    created_at TIMESTAMP,
    created_by VARCHAR(50)
)

CREATE TABLE blend_recipes_history (
    id,
    blend_id,
    bean_id,
    blending_ratio_percent,
    version,
    effective_from DATE,
    effective_to DATE,  # 언제까지 사용했는가
    reason VARCHAR(200),  # "비용 절감", "품질 개선" 등
    created_at TIMESTAMP,
    created_by VARCHAR(50)
)

2. 로스팅 기록에 레시피 버전 저장

CREATE TABLE roasting_logs (
    id,
    bean_id,
    blend_recipe_version_id,  # 어떤 버전의 레시피를 기준으로 했는가
    raw_weight_kg,
    roasted_weight_kg,
    loss_rate_percent,
    roasting_date,
    ...
)

3. 원가 계산 시 정확한 레시피 적용

def calculate_historical_blend_cost(roasting_log_id):
    """특정 로스팅 기록 기준의 정확한 원가 계산"""
    log = RoastingLog.get(roasting_log_id)
    recipe_version = log.blend_recipe_version  # 그때 사용한 레시피

    blend_cost = 0
    for component in recipe_version.components:
        bean_cost = component.bean.price_per_kg * component.ratio_percent
        blend_cost += bean_cost

    return blend_cost / (1 - log.loss_rate_percent/100)

4. 레시피 변경 시 영향 분석

def analyze_recipe_change(blend_id, new_recipe):
    """새로운 레시피 적용 시 영향도 분석"""
    current_recipe = Blend.get(blend_id).current_recipe
    current_cost = calculate_blend_cost(current_recipe)
    new_cost = calculate_blend_cost(new_recipe)

    cost_change = (new_cost - current_cost) / current_cost * 100

    return {
        'cost_change_percent': cost_change,
        'estimated_monthly_savings': cost_change * monthly_sales_volume,
        'affected_records': count_future_roasting_logs()
    }
```

---

### Issue 4: 데이터 마이그레이션 전략 부실

**현재 문제:**

```
T1-1 작업: "기존 로스팅 기록 마이그레이션 (Sheet1 데이터)"
- 단순 CSV→DB 변환만 설명
- 데이터 검증 없음
- 손실 시나리오 없음
- 롤백 전략 없음
```

**개선안:**

```
1. 마이그레이션 체크리스트

마이그레이션 전:
□ 원본 Excel 파일 백업 (3개 사본)
□ DB 스냅샷 생성
□ 마이그레이션 스크립트 테스트 환경 검증

마이그레이션 중:
□ 트랜잭션으로 wrapping
□ 진행률 로깅
□ 에러 시 자동 롤백

마이그레이션 후:
□ 행 수 검증 (원본 == 마이그레이션)
□ 합계 검증 (생두량 합 == 31,325.3kg)
□ 손실률 검증 (모두 17% ±1%)
□ 날짜 범위 검증 (2개월 분)
□ NULL 값 검증

2. 마이그레이션 함수 상세화

def migrate_roasting_logs(excel_file_path):
    '''
    Excel → DB 마이그레이션

    Returns:
        {
            'success': bool,
            'inserted_count': int,
            'validation_errors': [list],
            'warnings': [list],
            'total_raw_weight': float,
            'total_roasted_weight': float,
            'avg_loss_rate': float
        }
    '''
    with transaction:
        try:
            df = pd.read_excel(excel_file_path, sheet_name='Sheet1')

            # 데이터 정규화
            df = normalize_data(df)

            # 검증 1단계: 필수 컬럼
            required_columns = ['원두명', '생두량', '볶은량', '로스팅월']
            validate_columns(df, required_columns)

            # 검증 2단계: 데이터 타입 및 범위
            for idx, row in df.iterrows():
                bean = Bean.get_by_name(row['원두명'])
                if not bean:
                    raise ValidationError(f"원두 '{row['원두명']}' 없음")

                if row['생두량'] <= 0:
                    raise ValidationError(f"행 {idx}: 생두량 > 0 필수")

                if row['볶은량'] <= 0 or row['볶은량'] > row['생두량']:
                    raise ValidationError(f"행 {idx}: 0 < 볶은량 <= 생두량")

                loss_rate = (row['생두량'] - row['볶은량']) / row['생두량']
                if loss_rate < 0.10 or loss_rate > 0.25:
                    warnings.append(
                        f"행 {idx}: 손실률 {loss_rate:.1%} (정상범위 10~25%)"
                    )

            # 데이터 삽입
            for idx, row in df.iterrows():
                log = RoastingLog(
                    bean_id=Bean.get_by_name(row['원두명']).id,
                    raw_weight_kg=row['생두량'],
                    roasted_weight_kg=row['볶은량'],
                    roasting_month=row['로스팅월'],
                    notes=f"Migrated from Excel row {idx+1}"
                )
                db.session.add(log)

            db.session.commit()

            # 사후 검증
            inserted = RoastingLog.count()
            total_raw = RoastingLog.sum('raw_weight_kg')
            total_roasted = RoastingLog.sum('roasted_weight_kg')

            return {
                'success': True,
                'inserted_count': len(df),
                'validation_errors': [],
                'warnings': warnings,
                'total_raw_weight': total_raw,
                'total_roasted_weight': total_roasted,
                'avg_loss_rate': (total_raw - total_roasted) / total_raw
            }

        except Exception as e:
            db.session.rollback()
            return {
                'success': False,
                'validation_errors': [str(e)],
                'warnings': warnings
            }

3. 롤백 전략

def rollback_migration(migration_timestamp):
    '''특정 시점으로 DB 롤백'''

    # 방법 1: 스냅샷 복원 (권장)
    restore_from_snapshot(migration_timestamp)

    # 방법 2: 감사 로그 기반 reverse
    audit_logs = AuditLog.filter(
        created_at > migration_timestamp,
        operation IN ('INSERT', 'UPDATE', 'DELETE')
    )

    for log in reversed(audit_logs):
        if log.operation == 'INSERT':
            # 삽입한 행 삭제
            session.execute(
                f"DELETE FROM {log.table_name} WHERE id = {log.record_id}"
            )
        # UPDATE, DELETE도 유사하게 처리

4. 마이그레이션 UI

pages/0_마이그레이션.py
┌────────────────────────────────┐
│   데이터 마이그레이션           │
├────────────────────────────────┤
│ [Excel 파일 업로드]             │
│                                 │
│ 📊 미리보기:                     │
│ - 행 수: 60                      │
│ - 생두량: 31,325.3 kg           │
│ - 로스팅량: 26,000 kg           │
│ - 평균 손실률: 17.0%            │
│                                 │
│ [검증]                          │
│ ✓ 필수 컬럼                      │
│ ✓ 데이터 타입                    │
│ ✓ 값 범위                        │
│ ⚠️ 경고: 3개 (손실률 편차)      │
│                                 │
│ [실행] [취소]                    │
└────────────────────────────────┘

진행 중:
┌────────────────────────────────┐
│ 마이그레이션 진행 중...         │
│ ████████░░ 80%                 │
│                                 │
│ 처리 중: 48/60 행                │
│ 예상 시간: 5초 남음             │
└────────────────────────────────┘

완료:
✅ 마이그레이션 완료!
   - 삽입: 60 행
   - 경고: 3개 (검토 필요)
   - 총 생두량: 31,325.3 kg ✓
   - 평균 손실률: 17.0% ✓

   [상세 보고서] [처음으로]
```

---

### Issue 5: 성능 전략 부재

**현재 문제:**

```
T4 (테스트) 단계에만 "성능 최적화"라고 함
- 구체적 성능 목표 없음
- 병목 지점 분석 없음
- 캐싱 전략 없음
- 페이지네이션 없음
```

**예상 성능 문제:**

```
시나리오 1: 월별 그리드 조회
- 13종 원두 × 12개월 = 156개 셀
- 각 셀마다 손실률 계산 (DB 쿼리)
- st.data_editor는 렌더링 비용 높음
→ 예상: 3~5초 (허용치 2초 초과)

시나리오 2: 분석 차트
- Plotly는 대용량 데이터에서 느림
- 월별 × 원두별 × 손실률 계산
→ 예상: 2~3초

시나리오 3: 보고서 생성
- PDF 생성 (ReportLab) 비용 높음
- 여러 차트 포함 시 5~10초
→ 예상: 5~10초 (허용)
```

**개선안:**

```
1. 성능 목표 설정

| 페이지 | 목표 | 측정 방법 |
|--------|------|---------|
| 대시보드 | < 1초 | load_time |
| 로스팅 기록 | < 1.5초 | load_time |
| 월별 그리드 | < 2초 | load_time + edit_time |
| 블렌딩 관리 | < 1초 | load_time |
| 분석 페이지 | < 2.5초 | load_time |
| 보고서 생성 | < 5초 | generation_time |

2. 캐싱 전략

@st.cache_data(ttl=3600)  # 1시간
def get_monthly_summary():
    """월별 요약 데이터 (변경 적음)"""
    return RoastingService.get_monthly_summary()

@st.cache_data(ttl=300)  # 5분
def get_roasting_logs(month):
    """월별 로스팅 기록 (자주 변경)"""
    return RoastingService.get_monthly_records(month)

@st.cache_resource
def get_db_connection():
    """DB 연결 풀 (재사용)"""
    return create_engine(DATABASE_URL, poolclass=QueuePool)

3. 데이터베이스 최적화

CREATE INDEX idx_roasting_month ON roasting_logs(roasting_month);
CREATE INDEX idx_bean_id_month ON roasting_logs(bean_id, roasting_month);
CREATE INDEX idx_roasting_date ON roasting_logs(roasting_date);

CREATE VIEW monthly_summary AS
SELECT
    roasting_month,
    bean_id,
    SUM(raw_weight_kg) as total_raw,
    SUM(roasted_weight_kg) as total_roasted,
    (SUM(raw_weight_kg) - SUM(roasted_weight_kg)) / SUM(raw_weight_kg) as loss_rate
FROM roasting_logs
GROUP BY roasting_month, bean_id;

4. Streamlit 최적화

# 현재 (느림):
for month in months:
    for bean in beans:
        log = get_roasting_log(month, bean)  # N개의 DB 쿼리
        st.write(log)

# 개선:
@st.cache_data
def get_all_logs_at_once():
    return RoastingService.get_monthly_records_batch(months, beans)

logs = get_all_logs_at_once()
df = pd.DataFrame(logs)
st.dataframe(df)

5. 월별 그리드 성능 개선

# 현재:
editor_data = []
for month in months:
    for bean in beans:
        log = get_roasting_log(month, bean)
        editor_data.append(log)
edited_df = st.data_editor(editor_data)  # 156개 셀 렌더링

# 개선:
# 1단계: 데이터 미리 로드 (캐시)
@st.cache_data(ttl=300)
def get_grid_data(year, month_range):
    return RoastingService.get_grid_data(year, month_range)

# 2단계: 필요한 달만 표시 (페이지네이션)
selected_month = st.selectbox("월 선택", months)
grid_data = get_grid_data(2025, [selected_month])

# 3단계: 계산 최적화 (전용 함수)
def calculate_grid_with_loss(grid_data):
    """손실률을 한 번에 계산"""
    grid_data['loss_rate'] = (
        (grid_data['raw_weight'] - grid_data['roasted_weight']) /
        grid_data['raw_weight'] * 100
    ).round(2)
    return grid_data

grid = calculate_grid_with_loss(grid_data)
edited_grid = st.data_editor(grid, key=f"grid_{selected_month}")

6. 성능 모니터링

app/utils/performance.py:
```python
import time
from functools import wraps

def measure_time(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start

        st.session_state['timings'].append({
            'function': func.__name__,
            'elapsed_ms': elapsed * 1000,
            'timestamp': datetime.now()
        })

        if elapsed > 2:  # 경고 임계값
            st.warning(f"⚠️ {func.__name__} took {elapsed:.2f}s")

        return result
    return wrapper

@measure_time
def get_roasting_logs(month):
    ...
```

pages/9_성능모니터.py:
┌────────────────────────────────┐
│   성능 모니터링                  │
├────────────────────────────────┤
│ 최근 10분 성능 통계             │
│                                 │
│ 함수명          | 평균 | 최대   │
│ get_roasting_logs | 120ms | 340ms │
│ calculate_cost | 45ms  | 120ms  │
│ render_chart   | 850ms | 1.2s   │
│                                 │
│ 느린 함수 순위:                  │
│ 1. render_chart (850ms)        │
│ 2. get_roasting_logs (120ms)   │
│ 3. calculate_cost (45ms)       │
└────────────────────────────────┘
```

---

### Issue 6: 권한 관리 미구체화

**현재 문제:**

```
Phase 4에서 "사용자 권한 관리"라고만 함
- 어떤 역할이 필요한가?
- 각 역할의 권한은?
- 로그인 인증은?
```

**개선안:**

```
1. 사용자 역할 정의

역할            | 권한
───────────────┼──────────────────
관리자          | 모든 권한 (시스템 설정, 데이터 삭제 등)
점주            | 분석, 보고서 생성, 판매가 설정
담당자          | 로스팅 기록 입력/편집, 기본 분석
직원            | 로스팅 기록 조회만 (읽기 전용)
외부(고객)      | 공개 대시보드만 (읽기 전용)

2. 페이지별 권한 매트릭스

페이지                | 관리자 | 점주 | 담당자 | 직원 | 외부
─────────────────────┼────────┼────┼─────┼────┼────
1_대시보드           | R/W   | R   | R   | R  | R
2_로스팅기록         | R/W   | -   | R/W | R  | -
3_영수증형식         | R/W   | -   | R/W | -  | -
4_블렌딩관리         | R/W   | R/W | R   | -  | -
5_원가계산           | R/W   | R   | R   | -  | -
6_분석               | R/W   | R   | R   | -  | R (공개만)
7_보고서             | R/W   | R/W | -   | -  | -
8_설정               | R/W   | -   | -   | -  | -
0_마이그레이션       | R/W   | -   | -   | -  | -

R = 읽기, W = 쓰기, - = 접근 불가

3. 데이터베이스 테이블 추가

CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(100),
    role VARCHAR(20),  -- admin, owner, staff, worker, guest
    is_active BOOLEAN DEFAULT true,
    last_login TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE user_permissions (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    page_name VARCHAR(100),
    can_read BOOLEAN DEFAULT false,
    can_write BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE(user_id, page_name)
);

CREATE TABLE access_logs (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    page_name VARCHAR(100),
    action VARCHAR(20),  -- view, edit, delete
    resource_id INTEGER,
    status VARCHAR(20),  -- success, denied, error
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

4. 인증/권한 미들웨어

app/utils/auth.py:
```python
import streamlit as st
from functools import wraps

def require_login(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        if 'user' not in st.session_state:
            st.error("❌ 로그인이 필요합니다")
            st.stop()
        return func(*args, **kwargs)
    return wrapper

def require_role(*allowed_roles):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            user = st.session_state.get('user')
            if not user or user['role'] not in allowed_roles:
                st.error(f"❌ 접근 권한이 없습니다 (필요: {allowed_roles})")
                st.stop()
            return func(*args, **kwargs)
        return wrapper
    return decorator

def require_permission(page_name, action='read'):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            user = st.session_state.get('user')
            has_permission = check_permission(
                user['id'], page_name, action
            )
            if not has_permission:
                st.error(f"❌ '{page_name}' {action} 권한이 없습니다")
                st.stop()
            return func(*args, **kwargs)
        return wrapper
    return decorator

# 사용 예시:
@require_login
@require_role('admin', 'owner')
def admin_settings():
    st.write("관리자 설정")

@require_login
@require_permission('로스팅기록', 'write')
def roasting_input():
    st.write("로스팅 기록 입력")
```

5. 로그인 페이지

pages/00_로그인.py:
┌────────────────────────────────┐
│   The Moon Drip BAR             │
│   로스팅 관리 시스템            │
├────────────────────────────────┤
│                                 │
│ 사용자명: [____________]         │
│ 비밀번호: [____________]        │
│                                 │
│           [로그인]              │
│                                 │
│ 기본 사용자:                     │
│ - admin / admin                │
│ - owner / owner1               │
│ - staff / staff1               │
│                                 │
│ ⓘ 문의: 관리자 연락처          │
└────────────────────────────────┘

6. 감시 로그 (이미 있음)
audit_logs 테이블에 모든 변경 기록:
- 누가 (user_id)
- 언제 (timestamp)
- 뭘 했는가 (operation)
- 결과 (success/denied)
```

---

### Issue 7: Excel 양방향 동기화 위험

**현재 문제:**

```
T2-7: "Excel 동기화 서비스"
- 단방향인가? 양방향인가?
- 충돌 해결은?
- 스케줄은?
```

**개선안:**

```
1. 동기화 전략 정의

옵션 1: 단방향 (DB → Excel)
- Excel은 읽기 전용 (백업)
- 모든 입력은 웹 UI를 통해
- 간단하고 안전
- 추천: ✓

옵션 2: 양방향 (DB ↔ Excel)
- Excel에서도 입력 가능
- 충돌 해결 필요
- 복잡함
- 추천: ✗ (초기 단계에서)

2. 단방향 동기화 (권장)

def sync_to_excel(output_file):
    '''DB → Excel 내보내기'''

    # 1. 로스팅 기록 내보내기
    logs_df = pd.read_sql(
        """SELECT
               roasting_month,
               bean.name,
               roasting_log.raw_weight_kg,
               roasting_log.roasted_weight_kg,
               roasting_log.loss_rate_percent,
               roasting_log.roasting_date
           FROM roasting_logs
           JOIN beans ON roasting_logs.bean_id = beans.id
           ORDER BY roasting_month, bean.name
        """,
        db.session
    )

    # 2. 블렌드 레시피 내보내기
    recipe_df = pd.read_sql(
        """SELECT
               blend.name as blend_name,
               bean.name as bean_name,
               blend_recipe.blending_ratio_percent
           FROM blend_recipes
           JOIN blends ON blend_recipes.blend_id = blends.id
           JOIN beans ON blend_recipes.bean_id = beans.id
           ORDER BY blend.name, bean.name
        """,
        db.session
    )

    # 3. 원가 분석 내보내기
    cost_df = calculate_monthly_blend_costs()

    # 4. Excel 파일 작성
    with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
        logs_df.to_excel(writer, sheet_name='Sheet1', index=False)
        recipe_df.to_excel(writer, sheet_name='Sheet1(2)', index=False)
        cost_df.to_excel(writer, sheet_name='원가분석', index=False)

        # 포맷팅
        format_excel_sheet(writer, 'Sheet1')

def sync_from_excel(input_file):
    '''Excel → DB 가져오기 (초기 마이그레이션에만 사용)'''

    # 이 함수는 T1-1에서 한 번만 실행
    # 이후에는 사용하지 않음
    return migrate_roasting_logs(input_file)

3. 동기화 스케줄

# 매일 자정에 자동 동기화
from apscheduler.schedulers.background import BackgroundScheduler

scheduler = BackgroundScheduler()
scheduler.add_job(
    func=sync_to_excel,
    trigger="cron",
    hour=0,
    minute=0,
    args=["Data/roasting_data_export.xlsx"]
)
scheduler.start()

또는 수동 버튼:
pages/8_설정.py에 "지금 내보내기" 버튼

4. 충돌 처리 (양방향일 경우만)

def merge_changes(db_records, excel_records):
    '''마지막 쓰기 우선 전략 (LWW)'''

    for key in set(db_records.keys()) | set(excel_records.keys()):
        if key not in db_records:
            # Excel에만 있음: DB에 추가
            insert_to_db(excel_records[key])
        elif key not in excel_records:
            # DB에만 있음: 유지
            pass
        else:
            # 둘 다 있음: 최신 timestamp 우선
            db_ts = db_records[key]['updated_at']
            excel_ts = excel_records[key]['updated_at']

            if excel_ts > db_ts:
                # Excel이 더 최신: Excel 데이터 사용
                update_in_db(excel_records[key])
            # else: DB가 최신 유지
```

---

## 🟡 보조 이슈 분석

### Issue 8: 일정 계획의 현실성 부족

**문제:**
```
- Phase 1: 1.5주 (T1-1~T1-5)
- Phase 2: 2주 (T2-1~T2-8)
- Phase 3: 2.5주 (T3-1~T3-9)
- 합계: 6.5주 (평일 기준 30일)

위험 요소:
1. 버퍼 0일 (예상 vs 실제 편차 처리 불가)
2. 마이그레이션 복잡도 과소평가 (실제 2배)
3. 테스트 기간 과소평가 (1주는 부족)
4. 이전 코드 통합 전략 없음
```

**개선안:**
```
수정된 일정:

Phase 1: 1.5주 → 2주 (버퍼 +0.5주)
- 마이그레이션 복잡도 증가 고려
- 검증 및 수정 시간

Phase 2: 2주 → 2.5주 (버퍼 +0.5주)
- Unit test 작성 시간
- 코드 리뷰 시간

Phase 3: 2.5주 → 3주 (버퍼 +0.5주)
- UI/UX 반복 개선
- 성능 최적화

Phase 4: 1주 → 2주 (버퍼 +1주)
- 통합 테스트 상세화
- UAT 반복

Phase 5: 1주 → 1주 (유지)

Buffer: 1주 (예상 지연 대응)

수정된 합계: 6.5주 → 9주 (40% 증가)

일정 그래프:
Phase 1: [======]        2주
Phase 2:       [========]       2.5주
Phase 3:              [==========]     3주
Phase 4:                      [========]    2주
Phase 5:                              [====] 1주
Buffer:                                       [=] 1주

────────────────────────────────────────
총 예상 기간: 9주 (약 2개월)
```

---

### Issue 9: 테스트 전략 부실

**현재:**
```
T2-8: "Unit Test 작성 (2일)"
- 너무 짧음
- 테스트 커버리지 미정
- 통합 테스트 부재
```

**개선안:**

```
1. 테스트 전략 수정

단계별 테스트:
├── 단위 테스트 (Unit Tests)
│   ├── CostService 함수들
│   ├── AnalyticsService 함수들
│   ├── RoastingService CRUD
│   └── 검증 함수들
│   목표: 100% 커버리지 (핵심 로직)
│
├── 통합 테스트 (Integration Tests)
│   ├── 마이그레이션 → 검증 흐름
│   ├── 로스팅 기록 입력 → 원가 계산
│   ├── 블렌드 변경 → 영향도 분석
│   └── Excel 동기화 → 검증
│   목표: 주요 사용 케이스 100%
│
├── 성능 테스트 (Performance Tests)
│   ├── 월별 그리드 렌더링 < 2초
│   ├── 분석 차트 생성 < 2.5초
│   ├── 보고서 생성 < 5초
│   └── DB 쿼리 < 500ms
│   목표: 모든 페이지 목표 달성
│
└── 사용자 수용 테스트 (UAT)
    ├── 담당자: 영수증 형식 입력
    ├── 점주: 분석 및 리포트
    ├── 직원: 로스팅 기록 조회
    └── 실제 업무 시나리오
    목표: 100% 만족도

2. 테스트 코드 구조

tests/
├── unit/
│   ├── test_cost_service.py
│   ├── test_analytics_service.py
│   ├── test_roasting_service.py
│   └── test_validators.py
├── integration/
│   ├── test_migration_flow.py
│   ├── test_roasting_to_cost_flow.py
│   ├── test_recipe_change_flow.py
│   └── test_excel_sync_flow.py
├── performance/
│   ├── test_grid_performance.py
│   ├── test_chart_performance.py
│   └── test_db_query_performance.py
└── fixtures/
    ├── sample_roasting_logs.json
    ├── sample_blends.json
    └── sample_beans.json

3. 테스트 예시

# test_cost_service.py
import pytest
from app.services.cost_service import CostService

class TestCostService:

    @pytest.fixture
    def setup(self):
        """테스트 데이터 준비"""
        self.service = CostService()
        self.full_moon_blend = Blend.get_by_name("Full Moon")

    def test_calculate_blend_cost_per_kg(self, setup):
        """블렌드 원가 계산 테스트"""
        # 테스트 데이터
        bean_costs = {
            'Masai': 30000,      # ₩/kg
            'Antigua': 25000,
            'Momora': 20000,
            'g4': 18000
        }

        # 실행
        blend_cost = self.service.calculate_blend_cost_per_kg(
            self.full_moon_blend.id,
            bean_costs
        )

        # 검증
        expected = (
            30000 * 0.40 +  # Masai 40%
            25000 * 0.40 +  # Antigua 40%
            20000 * 0.10 +  # Momora 10%
            18000 * 0.10    # g4 10%
        )
        assert blend_cost == pytest.approx(expected)

    def test_calculate_final_cost_with_loss_rate(self, setup):
        """손실률 반영 최종 원가 계산"""
        blend_cost = 25800
        loss_rate = 0.17

        final_cost = self.service.calculate_final_cost(
            blend_cost,
            loss_rate
        )

        expected = 25800 / (1 - 0.17)
        assert final_cost == pytest.approx(expected)

    def test_invalid_loss_rate(self, setup):
        """범위 벗어난 손실률 검증"""
        with pytest.raises(ValidationError):
            self.service.calculate_final_cost(25800, 0.5)  # 50% 손실?

4. pytest 설정

pytest.ini:
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts =
    -v
    --cov=app
    --cov-report=html
    --cov-report=term-missing
    --tb=short

5. CI/CD 통합

.github/workflows/tests.yml:
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-python@v2
        with:
          python-version: 3.12

      - name: Install dependencies
        run: pip install -r requirements.txt pytest pytest-cov

      - name: Run unit tests
        run: pytest tests/unit

      - name: Run integration tests
        run: pytest tests/integration

      - name: Run performance tests
        run: pytest tests/performance -m performance

      - name: Upload coverage
        uses: codecov/codecov-action@v2
        with:
          files: ./coverage.xml
          flags: unittests
          fail_ci_if_error: true
```

---

## 🟢 추천 개선사항

### Issue 10: 모니터링 및 알림 부재

```
추천: Phase 5 이후 "Phase 6: 운영 최적화"로 추가

Phase 6 작업:
- T6-1: 모니터링 대시보드 (손실률 이상, DB 성능)
- T6-2: 알림 시스템 (Slack 통합)
- T6-3: 자동 백업 스크립트
- T6-4: 로그 분석 및 보고

예시:
def send_alert(message, severity='warning'):
    '''Slack으로 알림 전송'''
    if severity == 'critical':
        send_slack('@channel ' + message)
    elif severity == 'warning':
        send_slack('#roasting-alerts ' + message)

# 사용 예시:
if loss_rate > 20:
    send_alert(
        f"⚠️ {month} {bean_name}: 손실률 {loss_rate:.1%} (정상 17%)",
        severity='warning'
    )

if db_response_time > 1000:
    send_alert(
        f"🚨 DB 느림: {db_response_time}ms",
        severity='critical'
    )
```

---

## 📋 개선 우선순위

| 우선순위 | 이슈 | 영향도 | 노력도 | 추천 |
|---------|------|--------|--------|------|
| **P0** | Issue 1: 혼합률 정의 명확화 | 높음 | 낮음 | **필수** |
| **P0** | Issue 4: 마이그레이션 상세화 | 높음 | 중간 | **필수** |
| **P1** | Issue 2: 손실률 검증 | 중간 | 중간 | **권장** |
| **P1** | Issue 3: 블렌드 레시피 버전 관리 | 중간 | 높음 | 권장 |
| **P1** | Issue 5: 성능 전략 | 중간 | 높음 | 권장 |
| **P2** | Issue 6: 권한 관리 구체화 | 낮음 | 중간 | 선택 |
| **P2** | Issue 7: Excel 동기화 전략 | 낮음 | 낮음 | 선택 |
| **P3** | Issue 8: 일정 재계획 | 낮음 | 낮음 | 선택 |
| **P3** | Issue 9: 테스트 전략 확대 | 낮음 | 높음 | 선택 |

---

## 📝 개선된 일정 계획

```
현재 계획: 6.5주
개선된 계획: 9주 (↑ 38% 증가)

Phase 1: 기초 데이터 구축
  └─ T1-1: 마이그레이션 (상세화됨)        2주

Phase 2: 백엔드 서비스
  ├─ T2-1~T2-4: 핵심 서비스                 1.5주
  ├─ T2-5: CostService (상세화)            2일
  ├─ T2-6~T2-8: 테스트 및 동기화           1주
  └─ 코드 리뷰 및 수정                      3일
  총 2.5주

Phase 3: 프론트엔드 개발
  ├─ T3-1~T3-5: 5개 핵심 페이지              2주
  ├─ T3-6~T3-9: 4개 추가 페이지 + 성능 최적화  1주
  └─ UI/UX 반복 개선                       3일
  총 3주

Phase 4: 테스트 및 최적화
  ├─ 단위 테스트 (추가)                      3일
  ├─ 통합 테스트                            2일
  ├─ 성능 테스트                            2일
  ├─ UAT 및 버그 수정                       3일
  └─ 최종 검증                              2일
  총 2주

Phase 5: 배포 및 운영
  ├─ 운영 매뉴얼                            1일
  ├─ 직원 교육                              1일
  ├─ 배포                                   1일
  └─ 초기 지원                              1주
  총 1.5주

Buffer: 1주 (예상 지연 대응)

─────────────────────────────────
총 예상: 9주 (약 2개월)
─────────────────────────────────
```

---

## ✅ 최종 체크리스트 (수정)

```
핵심 이슈 해결:
☐ Issue 1: 혼합률(%) 정의 문서화
☐ Issue 1: CostService 함수 재정의
☐ Issue 2: 손실률 임계값 설정
☐ Issue 2: 손실률 이상 탐지 로직
☐ Issue 3: blend_recipes 버전 관리 추가
☐ Issue 4: 마이그레이션 상세 가이드 작성
☐ Issue 5: 성능 목표 및 최적화 전략
☐ Issue 6: 권한 관리 테이블 설계
☐ Issue 7: Excel 동기화 전략 결정

일정 및 테스트:
☐ 일정 재계획 (9주)
☐ 테스트 전략 확대
☐ CI/CD 파이프라인 구축

운영:
☐ 모니터링 대시보드 설계
☐ 알림 시스템 설계
☐ 백업/복구 절차 문서화
```

---

## 🎯 다음 단계

1. **P0 이슈 해결** (필수)
   - Issue 1: 혼합률 명확화 + CostService 재설계
   - Issue 4: 마이그레이션 가이드 상세화

2. **플랜 v2.2 작성** (1~2일)
   - 개선 사항 반영
   - 일정 재계획 (9주)
   - 테스트 전략 추가

3. **Phase 1 시작**
   - T1-1: 마이그레이션 가이드 작성
   - 테스트 환경 구축

---

**평가자:** AI 전문가
**검토 날짜:** 2025-10-29
**권장사항:** v2 승인 전 P0 이슈 필수 해결, 일정 재계획 권장
